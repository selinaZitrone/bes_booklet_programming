When we are conducting experiments we often conduct rigorous testing to ensure that results are reliable and accurate - why should that be any different when you are developing your code? By testing your code you can be sure that it is working as intended, as well as identify any limitations of the code. While the idea of developing tests may feel a bit excessive when starting out with coding it is valuable to be aware of the principles as it still provides a conceptual basis from which you can develop code that meets the expectations associated with conducting 'good' science.

### Unit tests

Unit testing focuses on testing *parts* of code to ensure that a function is doing what it should be doing and meets the specified requirements in a formalised and automated manner. At a high level one can do this by inputting a value into the function for which you know what the output (answer) should be and testing if the answer that the function gives you is the same. Of course this might not always be that easy since you might have many moving parts to a function, in which case the aim should be to 'control' a subset of the parts and test others.

### Integration tests

Integration tests are more about ensuring that the parts fit into the whole. So going back to the data analysis example - we want to make sure that the output from our data cleaning function is able to seamlessly act as the input for our data analysis function. Alternatively you might want to run integration tests when you are introducing new features (functions) to your project and need to make sure that these do not break or alter the behaviour of your existing workflow.

### Test-driven development

Test-driven development (TDD) is an approach to software development whereby tests are written before the actual code, with the idea that this will ensure the reliability of your code since you are focusing on identifying the desired behaviour of the system from the start. Essentially the idea is that you write a small test that defines the desired functionality, write the minimum code necessary to pass that test, and refactor the code to improve structure and performance. This approach is a way of ensuring the reliability of your code since you are predefining the parameters as well as expected outputs before you even start coding up the project.